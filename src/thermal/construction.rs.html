<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src&#x2F;construction.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>construction.rs - source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.9.0/dist/katex.min.css" integrity="sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/katex@0.9.0/dist/katex.min.js" integrity="sha384-jmxIlussZWB7qCuB+PgKG1uLjjxbVVIayPJwi6cG6Zb4YKq0JIw+OMnkkEC7kYCq" crossorigin="anonymous"></script>
<script>
  "use strict";
  document.addEventListener("DOMContentLoaded", function () {
      var maths = document.getElementsByClassName("language-math");
      for (var i=0; i<maths.length; i++) {
          var el = maths[i];
          katex.render(el.innerText, el, {displayMode: true});
      }

      var codes = document.getElementsByTagName("code");
      for (i=0; i<codes.length; i++) {
          el = codes[i];
          if (el.classList.contains("language-math")) continue;
          if (el.classList.contains("language-inline-math")) {
              katex.render(el.innerText, el);
              continue;
          }

          var parent = el.parentNode;
          if (parent.nodeName.toLowerCase() === "pre") continue;
          // TODO: Can this be done with DOM manipulation rather than string manipulation?
          // https://stackoverflow.com/q/48438067/3019990
          var inlineMath = "$" + el.outerHTML + "$";
          if (parent.innerHTML.indexOf(inlineMath) !== -1) {
              el.classList.add("language-inline-math");
              parent.innerHTML = parent.innerHTML.replace("$" + el.outerHTML + "$", el.outerHTML);
              i--;
          }
      }
  });
</script>

<style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../thermal/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
<span id="643">643</span>
<span id="644">644</span>
<span id="645">645</span>
<span id="646">646</span>
<span id="647">647</span>
<span id="648">648</span>
<span id="649">649</span>
<span id="650">650</span>
<span id="651">651</span>
<span id="652">652</span>
<span id="653">653</span>
<span id="654">654</span>
<span id="655">655</span>
<span id="656">656</span>
<span id="657">657</span>
<span id="658">658</span>
<span id="659">659</span>
<span id="660">660</span>
<span id="661">661</span>
<span id="662">662</span>
<span id="663">663</span>
<span id="664">664</span>
<span id="665">665</span>
<span id="666">666</span>
<span id="667">667</span>
<span id="668">668</span>
<span id="669">669</span>
<span id="670">670</span>
<span id="671">671</span>
<span id="672">672</span>
<span id="673">673</span>
<span id="674">674</span>
<span id="675">675</span>
<span id="676">676</span>
<span id="677">677</span>
<span id="678">678</span>
<span id="679">679</span>
<span id="680">680</span>
<span id="681">681</span>
<span id="682">682</span>
<span id="683">683</span>
<span id="684">684</span>
<span id="685">685</span>
<span id="686">686</span>
<span id="687">687</span>
<span id="688">688</span>
<span id="689">689</span>
<span id="690">690</span>
<span id="691">691</span>
<span id="692">692</span>
<span id="693">693</span>
<span id="694">694</span>
<span id="695">695</span>
<span id="696">696</span>
<span id="697">697</span>
<span id="698">698</span>
<span id="699">699</span>
<span id="700">700</span>
<span id="701">701</span>
<span id="702">702</span>
<span id="703">703</span>
<span id="704">704</span>
<span id="705">705</span>
<span id="706">706</span>
<span id="707">707</span>
<span id="708">708</span>
<span id="709">709</span>
<span id="710">710</span>
<span id="711">711</span>
<span id="712">712</span>
<span id="713">713</span>
<span id="714">714</span>
<span id="715">715</span>
<span id="716">716</span>
<span id="717">717</span>
<span id="718">718</span>
</pre><pre class="rust"><code><span class="comment">/*
MIT License
Copyright (c) 2021 Germán Molina
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/</span>

<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::Float</span>;

<span class="kw">use</span> <span class="ident">std::rc::Rc</span>;

<span class="kw">use</span> <span class="ident">matrix::Matrix</span>;

<span class="kw">use</span> <span class="ident">simple_model::Construction</span>;

<span class="doccomment">/// Given a Maximum element thickness ($`\Delta x_{max}`$) and a minimum timestep ($`\Delta t_{min}`$), this function</span>
<span class="doccomment">/// will find an arguibly good (i.e., stable and accurate) combination of $\\Delta t\$ and number of elements in each</span>
<span class="doccomment">/// layer of the construction.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This function recursively increases the model&#39;s timestep subdivisions (`n`) in order to reduce $`\Delta t`$ to numbers</span>
<span class="doccomment">/// that respect the restrictions of (1) stability, (2) $`\Delta x_{max}`$, and (3) $`\Delta t_{min}`$. In other words,</span>
<span class="doccomment">/// it searches (by testing $`\Delta t_{model}/1`$, $`\Delta t_{model}/2`$, $`\Delta t_{model}/3`$, ... $`\Delta t_{model}/n`$)</span>
<span class="doccomment">/// for the minimum `n` that respects this restrictions</span>
<span class="doccomment">///</span>
<span class="doccomment">/// # The math behind it</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The first thing to know is that the walls in this module march</span>
<span class="doccomment">/// through time using a 4th order [Runga-Kutte](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods)</span>
<span class="doccomment">/// (a.k.a., RK4). The second thing to know is that the RK4 method is</span>
<span class="doccomment">/// more stable than the [Euler method](https://en.wikipedia.org/wiki/Euler_method),</span>
<span class="doccomment">/// and thus the restrictions of stability for the Euler method can be considered</span>
<span class="doccomment">/// to be a conservative restriction for the RK4. Hence, this function uses the</span>
<span class="doccomment">/// Euler method restrictions.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Now, as explained in the [`build_thermal_network`] documentation, we are solving</span>
<span class="doccomment">/// the following equation:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```math</span>
<span class="doccomment">/// \dot{T} = \overline{C}^{-1} \overline{K}  T + \overline{C}^{-1} q</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// And thus the stability of the numerical method will depend on the matrix:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```math</span>
<span class="doccomment">/// \overline{K}^{\star} =\Delta t \overline{C}^{-1} \overline{K}</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Specifically, we don&#39;t want any of its [eigenvalues](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors)</span>
<span class="doccomment">/// $`\xi_1, \xi_2,\xi_3, ...`$ to be outside of the Euler method&#39;s stability region. Since this</span>
<span class="doccomment">/// matrix has onle Real eigenvalues, this is equivalent to saying:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```math</span>
<span class="doccomment">/// -2 &lt; \xi_i &lt; 0 ; \forall i</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// However, finding the eigenvalues for $`\overline{K}^{\star}`$ is far from trivial. So there is</span>
<span class="doccomment">/// yet another heuristic I am using: I am treating the case of a wall with 1 layer that is subdivided</span>
<span class="doccomment">/// into a single element as the limit case. I am not sure if this is correct, but most of the instabilities</span>
<span class="doccomment">/// I identified through Trial and Error corresponded to this case.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// For this limit case:</span>
<span class="doccomment">/// * $`R = \frac{\Delta x}{\lambda}`$</span>
<span class="doccomment">/// * $`C = \rho  c_p  \Delta x`$</span>
<span class="doccomment">///</span>
<span class="doccomment">/// thus the value of $`\overline{K}^{\star}`$ is:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```math</span>
<span class="doccomment">/// \overline{K}^{\star}=\begin{bmatrix}</span>
<span class="doccomment">/// -\frac{\Delta t}{C\times R} - \frac{\Delta t}{C\times R_s} &amp; \frac{\Delta t}{C\times R} \\</span>
<span class="doccomment">///  \frac{\Delta t}{C\times R} &amp; -\frac{\Delta t}{C\times R} - \frac{\Delta t}{C\times R_s}\\</span>
<span class="doccomment">/// \end{bmatrix}   </span>
<span class="doccomment">///```</span>
<span class="doccomment">/// Note that, in that equation, $`R_{si} = R_{so}`$. The reason for this is that this method</span>
<span class="doccomment">/// does not know the real values of $`R_{si}`$ and $`R_{so}`$, so it simply using a placeholder</span>
<span class="doccomment">/// value low enough to cover most general cases (`0.05`).</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Then, it can be found that the eigenvaues of this case—which we are treating as the limit case—are:</span>
<span class="doccomment">/// ```math</span>
<span class="doccomment">/// \xi_1 = -\frac{\Delta t} { R_s \rho c_p \Delta x }</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">/// ```math</span>
<span class="doccomment">/// \xi_2 = \xi_1 - 2 \frac{\Delta t \lambda}{ \rho  c_p  {\Delta x}^2}</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">/// Both these values are always negative, so we don&#39;t need to worry about</span>
<span class="doccomment">/// $`\xi_i &lt; 0 `$. Also, it can be noticed that $`\xi_2 &lt; \xi_1`$, meaning that</span>
<span class="doccomment">/// what we need to comply with for Euler&#39;s stability criteria is:</span>
<span class="doccomment">/// ```math</span>
<span class="doccomment">/// -\frac{\Delta t} { R_s \rho c_p \Delta x } - 2 \frac{\Delta t \lambda}{ \rho  c_p  {\Delta x}^2} &lt; -2</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Which means that the chosen $`\Delta x`$ must be greater than the (apparently only) positive</span>
<span class="doccomment">/// solution to equation:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```math</span>
<span class="doccomment">/// 0 = 2 {\Delta x}^2 - \left( \frac{\Delta t}{\rho c_p R_s} \right) \Delta x - \frac{2 \Delta t \lambda}{\rho c_p}</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// So, this method will identify a combination of $`\Delta t`$ and $`\Delta x`$ that</span>
<span class="doccomment">/// allows complying with this</span>
<span class="doccomment">///</span>
<span class="doccomment">/// All that said, the value for $`\Delta t`$ actually used by the final model is</span>
<span class="doccomment">/// actually half of what these equations use. This is because what we are using</span>
<span class="doccomment">/// is a heuristic and I want to be safe... ish</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">discretize_construction</span>(
    <span class="ident">construction</span>: <span class="kw-2">&amp;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Construction</span><span class="op">&gt;</span>,
    <span class="ident">model_dt</span>: <span class="ident">Float</span>,
    <span class="ident">max_dx</span>: <span class="ident">Float</span>,
    <span class="ident">min_dt</span>: <span class="ident">Float</span>,
) <span class="op">-</span><span class="op">&gt;</span> (<span class="ident">usize</span>, <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span>) {
    <span class="comment">// I could only think of how to make this recursively... so I did this.</span>
    <span class="kw">fn</span> <span class="ident">aux</span>(
        <span class="ident">construction</span>: <span class="kw-2">&amp;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Construction</span><span class="op">&gt;</span>,
        <span class="ident">main_dt</span>: <span class="ident">Float</span>,
        <span class="ident">n</span>: <span class="ident">usize</span>,
        <span class="ident">max_dx</span>: <span class="ident">Float</span>,
        <span class="ident">min_dt</span>: <span class="ident">Float</span>,
    ) <span class="op">-</span><span class="op">&gt;</span> (<span class="ident">usize</span>, <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span>) {
        <span class="kw">let</span> <span class="ident">dt</span> <span class="op">=</span> <span class="ident">main_dt</span> <span class="op">/</span> (<span class="ident">n</span> <span class="kw">as</span> <span class="ident">Float</span>);

        <span class="comment">// Choose a dx so that dt allows convergence.</span>
        <span class="comment">// stability is assured by (alpha * dt / dx^2 &lt;= 1/2 )</span>
        <span class="comment">// meaning, we need to satisfy dx &gt;= sqrt(0.5 * dt * thermal_cond/( dens * heat_cap  ))</span>

        <span class="comment">// So, for each layer</span>
        <span class="kw">let</span> <span class="ident">n_layers</span> <span class="op">=</span> <span class="ident">construction</span>.<span class="ident">materials</span>.<span class="ident">len</span>();
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">n_elements</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Vec::with_capacity</span>(<span class="ident">n_layers</span>);
        <span class="kw">const</span> <span class="ident">RS</span>: <span class="ident">Float</span> <span class="op">=</span> <span class="number">0.05</span>;

        <span class="kw">for</span> <span class="ident">n_layer</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">n_layers</span> {
            <span class="kw">let</span> <span class="ident">material</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">construction</span>.<span class="ident">materials</span>[<span class="ident">n_layer</span>];
            <span class="kw">let</span> <span class="ident">substance</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">material</span>.<span class="ident">substance</span>;

            <span class="comment">// Calculate the minimum_dx</span>
            <span class="kw">let</span> <span class="ident">thickness</span> <span class="op">=</span> <span class="ident">material</span>.<span class="ident">thickness</span>;
            <span class="kw">let</span> <span class="ident">k</span> <span class="op">=</span> <span class="ident">substance</span>.<span class="ident">thermal_conductivity</span>().<span class="ident">unwrap</span>();
            <span class="kw">let</span> <span class="ident">rho</span> <span class="op">=</span> <span class="ident">substance</span>.<span class="ident">density</span>().<span class="ident">unwrap</span>();
            <span class="kw">let</span> <span class="ident">cp</span> <span class="op">=</span> <span class="ident">substance</span>.<span class="ident">specific_heat_capacity</span>().<span class="ident">unwrap</span>();

            <span class="kw">let</span> <span class="ident">a_coef</span> <span class="op">=</span> <span class="number">2.</span>;
            <span class="kw">let</span> <span class="ident">b_coef</span> <span class="op">=</span> <span class="op">-</span><span class="ident">dt</span> <span class="op">/</span> (<span class="ident">rho</span> <span class="op">*</span> <span class="ident">cp</span> <span class="op">*</span> <span class="ident">RS</span>);
            <span class="kw">let</span> <span class="ident">c_coef</span> <span class="op">=</span> <span class="op">-</span><span class="number">2.</span> <span class="op">*</span> <span class="ident">dt</span> <span class="op">*</span> <span class="ident">k</span> <span class="op">/</span> (<span class="ident">rho</span> <span class="op">*</span> <span class="ident">cp</span>);
            <span class="kw">let</span> <span class="ident">disc</span> <span class="op">=</span> <span class="ident">b_coef</span> <span class="op">*</span> <span class="ident">b_coef</span> <span class="op">-</span> <span class="number">4.</span> <span class="op">*</span> <span class="ident">a_coef</span> <span class="op">*</span> <span class="ident">c_coef</span>;
            <span class="comment">// this should never happen...?</span>
            <span class="macro">debug_assert!</span>(<span class="ident">disc</span> <span class="op">&gt;</span><span class="op">=</span> <span class="number">0.</span>);

            <span class="comment">// One solution is apparently always negative...</span>
            <span class="comment">// i.e. it is meaningless</span>
            <span class="macro">debug_assert!</span>((<span class="op">-</span><span class="ident">b_coef</span> <span class="op">-</span> <span class="ident">disc</span>.<span class="ident">sqrt</span>()) <span class="op">/</span> (<span class="number">2.</span> <span class="op">*</span> <span class="ident">a_coef</span>) <span class="op">&lt;</span> <span class="number">0.</span>);

            <span class="comment">// The positive solution is the one we care about</span>
            <span class="kw">let</span> <span class="ident">min_dx</span> <span class="op">=</span> (<span class="op">-</span><span class="ident">b_coef</span> <span class="op">+</span> <span class="ident">disc</span>.<span class="ident">sqrt</span>()) <span class="op">/</span> (<span class="number">2.</span> <span class="op">*</span> <span class="ident">a_coef</span>);

            <span class="kw">if</span> <span class="ident">min_dx</span> <span class="op">&gt;</span> <span class="ident">thickness</span> {
                <span class="comment">// This means that this layer cannot comply with the</span>
                <span class="comment">// given timestep because its thickness leads to a dx that</span>
                <span class="comment">// does not ensure convergence...</span>
                <span class="comment">// check if there is room for reducing dt (hence reducing min_dx)</span>
                <span class="kw">let</span> <span class="ident">next_dt</span> <span class="op">=</span> <span class="ident">main_dt</span> <span class="op">/</span> ((<span class="ident">n</span> <span class="op">+</span> <span class="number">1</span>) <span class="kw">as</span> <span class="ident">Float</span>);
                <span class="kw">if</span> <span class="ident">next_dt</span> <span class="op">&gt;</span> <span class="ident">min_dt</span> {
                    <span class="comment">// If there is room for that, do it.</span>
                    <span class="kw">return</span> <span class="ident">aux</span>(<span class="ident">construction</span>, <span class="ident">main_dt</span>, <span class="ident">n</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">max_dx</span>, <span class="ident">min_dt</span>);
                } <span class="kw">else</span> {
                    <span class="comment">// otherwise, mark this layer as no-mass</span>
                    <span class="ident">n_elements</span>.<span class="ident">push</span>(<span class="number">0</span>);
                }
            } <span class="kw">else</span> {
                <span class="comment">// subdivide the layer, making all the elements of equal thickness</span>
                <span class="kw">let</span> <span class="ident">m</span> <span class="op">=</span> (<span class="ident">thickness</span> <span class="op">/</span> <span class="ident">min_dx</span>).<span class="ident">floor</span>();
                <span class="comment">// this case belongs to the other branch of this if/else</span>
                <span class="macro">debug_assert!</span>(<span class="ident">m</span> <span class="kw">as</span> <span class="ident">usize</span> <span class="op">!</span><span class="op">=</span> <span class="number">0</span>);
                <span class="kw">let</span> <span class="ident">dx</span> <span class="op">=</span> <span class="ident">thickness</span> <span class="op">/</span> <span class="ident">m</span>;
                <span class="kw">if</span> <span class="ident">dx</span> <span class="op">&gt;</span> <span class="ident">max_dx</span> {
                    <span class="comment">// If the found dx is larger than the max allowed d_x, try to change timestep</span>
                    <span class="comment">// check if there is room for reducing dt...</span>
                    <span class="kw">let</span> <span class="ident">next_dt</span> <span class="op">=</span> <span class="ident">main_dt</span> <span class="op">/</span> ((<span class="ident">n</span> <span class="op">+</span> <span class="number">1</span>) <span class="kw">as</span> <span class="ident">Float</span>);
                    <span class="kw">if</span> <span class="ident">next_dt</span> <span class="op">&gt;</span> <span class="ident">min_dt</span> {
                        <span class="comment">// If there is room for that, do it.</span>
                        <span class="kw">return</span> <span class="ident">aux</span>(<span class="ident">construction</span>, <span class="ident">main_dt</span>, <span class="ident">n</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">max_dx</span>, <span class="ident">min_dt</span>);
                    } <span class="kw">else</span> {
                        <span class="comment">// otherwise, mark this layer as no-mass</span>
                        <span class="ident">n_elements</span>.<span class="ident">push</span>(<span class="number">0</span>);
                    }
                } <span class="kw">else</span> {
                    <span class="comment">// &quot;dx&quot; is smaller than max_dx, and thus this works</span>
                    <span class="comment">// fine.</span>
                    <span class="ident">n_elements</span>.<span class="ident">push</span>(<span class="ident">m</span> <span class="kw">as</span> <span class="ident">usize</span>)
                }
            }
        }

        <span class="comment">// Check stability requirements...</span>
        <span class="comment">// stability is assured by (alpha * dt / dx^2 &lt;= 1/2 )</span>
        <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">debug_assertions</span>)]</span>
        {
            <span class="kw">for</span> (<span class="ident">n_layer</span>, <span class="kw">_</span>) <span class="kw">in</span> <span class="ident">n_elements</span>.<span class="ident">iter</span>().<span class="ident">enumerate</span>() {
                <span class="kw">let</span> <span class="ident">material</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">construction</span>.<span class="ident">materials</span>[<span class="ident">n_layer</span>];
                <span class="kw">let</span> <span class="ident">substance</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">material</span>.<span class="ident">substance</span>;

                <span class="comment">// Calculate the optimum_dx</span>
                <span class="kw">let</span> <span class="ident">thickness</span> <span class="op">=</span> <span class="ident">material</span>.<span class="ident">thickness</span>;
                <span class="kw">let</span> <span class="ident">k</span> <span class="op">=</span> <span class="ident">substance</span>.<span class="ident">thermal_conductivity</span>().<span class="ident">unwrap</span>();
                <span class="kw">let</span> <span class="ident">rho</span> <span class="op">=</span> <span class="ident">substance</span>.<span class="ident">density</span>().<span class="ident">unwrap</span>();
                <span class="kw">let</span> <span class="ident">cp</span> <span class="op">=</span> <span class="ident">substance</span>.<span class="ident">specific_heat_capacity</span>().<span class="ident">unwrap</span>();
                <span class="kw">let</span> <span class="ident">dt</span> <span class="op">=</span> <span class="ident">main_dt</span> <span class="op">/</span> <span class="ident">n</span> <span class="kw">as</span> <span class="ident">Float</span>;
                <span class="kw">let</span> <span class="ident">dx</span> <span class="op">=</span> <span class="ident">thickness</span> <span class="op">/</span> <span class="ident">n_elements</span>[<span class="ident">n_layer</span>] <span class="kw">as</span> <span class="ident">Float</span>;

                <span class="comment">// assert!(alpha * dt / dx / dx &lt;= 0.5);</span>
                <span class="kw">let</span> <span class="ident">lambda1</span> <span class="op">=</span> <span class="op">-</span><span class="ident">dt</span> <span class="op">/</span> (<span class="ident">RS</span> <span class="op">*</span> <span class="ident">rho</span> <span class="op">*</span> <span class="ident">cp</span> <span class="op">*</span> <span class="ident">dx</span>);
                <span class="kw">let</span> <span class="ident">r</span> <span class="op">=</span> <span class="ident">dx</span> <span class="op">/</span> <span class="ident">k</span>;
                <span class="kw">let</span> <span class="ident">lambda2</span> <span class="op">=</span> <span class="ident">lambda1</span> <span class="op">-</span> <span class="number">2.</span> <span class="op">*</span> <span class="ident">dt</span> <span class="op">/</span> (<span class="ident">r</span> <span class="op">*</span> <span class="ident">rho</span> <span class="op">*</span> <span class="ident">cp</span> <span class="op">*</span> <span class="ident">dx</span>);
                <span class="macro">assert!</span>(<span class="ident">lambda1</span> <span class="op">&gt;</span><span class="op">=</span> <span class="op">-</span><span class="number">2.</span>);
                <span class="macro">assert!</span>(<span class="ident">lambda1</span> <span class="op">&lt;</span><span class="op">=</span> <span class="number">0.</span>);
                <span class="macro">assert!</span>(<span class="ident">lambda2</span> <span class="op">&gt;</span><span class="op">=</span> <span class="op">-</span><span class="number">2.</span>);
                <span class="macro">assert!</span>(<span class="ident">lambda2</span> <span class="op">&lt;</span><span class="op">=</span> <span class="number">0.</span>);
            }
        }

        <span class="comment">// return</span>
        (<span class="ident">n</span>, <span class="ident">n_elements</span>)
    }
    <span class="ident">aux</span>(<span class="ident">construction</span>, <span class="ident">model_dt</span>, <span class="number">1</span>, <span class="ident">max_dx</span>, <span class="ident">min_dt</span>)
}

<span class="doccomment">/// In a discretization scheme, this function finds the</span>
<span class="doccomment">/// first and the last massive layers... the no-mass layers</span>
<span class="doccomment">/// before and after the first and last massive ones, respectively,</span>
<span class="doccomment">/// are just bulked with the values of RSi and RSo.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_first_and_last_massive_elements</span>(<span class="ident">n_elements</span>: <span class="kw-2">&amp;</span>[<span class="ident">usize</span>]) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(<span class="ident">usize</span>, <span class="ident">usize</span>), <span class="ident">String</span><span class="op">&gt;</span> {
    <span class="comment">// We need somethig to process!</span>
    <span class="kw">if</span> <span class="ident">n_elements</span>.<span class="ident">is_empty</span>() {
        <span class="kw">return</span> <span class="prelude-val">Err</span>(
            <span class="string">&quot;Impossible to check first and last massive layers in empty discretization scheme&quot;</span>
                .<span class="ident">to_string</span>(),
        );
    }
    <span class="kw">let</span> <span class="ident">n_layers</span> <span class="op">=</span> <span class="ident">n_elements</span>.<span class="ident">len</span>();

    <span class="comment">// Border cases: one layer</span>
    <span class="kw">if</span> <span class="ident">n_layers</span> <span class="op">=</span><span class="op">=</span> <span class="number">1</span> {
        <span class="kw">if</span> <span class="ident">n_elements</span>[<span class="number">0</span>] <span class="op">=</span><span class="op">=</span> <span class="number">0</span> {
            <span class="comment">// if the layer is no-mass, then return 0,0</span>
            <span class="kw">return</span> <span class="prelude-val">Ok</span>((<span class="number">0</span>, <span class="number">0</span>));
        } <span class="kw">else</span> {
            <span class="comment">// if the layer has mas,</span>
            <span class="kw">return</span> <span class="prelude-val">Ok</span>((<span class="number">0</span>, <span class="number">1</span>));
        }
    }

    <span class="comment">// find the first and last massive layers</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">first_massive</span> <span class="op">=</span> <span class="ident">n_layers</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">last_massive</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">any_massive</span> <span class="op">=</span> <span class="bool-val">false</span>;
    <span class="kw">for</span> (<span class="ident">i</span>, <span class="ident">nodes</span>) <span class="kw">in</span> <span class="ident">n_elements</span>.<span class="ident">iter</span>().<span class="ident">enumerate</span>() {
        <span class="kw">if</span> <span class="kw-2">*</span><span class="ident">nodes</span> <span class="op">&gt;</span> <span class="number">0</span> {
            <span class="kw">if</span> <span class="ident">first_massive</span> <span class="op">&gt;</span> <span class="ident">i</span> {
                <span class="ident">first_massive</span> <span class="op">=</span> <span class="ident">i</span>;
            }
            <span class="kw">if</span> <span class="ident">last_massive</span> <span class="op">&lt;</span> <span class="ident">i</span> {
                <span class="ident">last_massive</span> <span class="op">=</span> <span class="ident">i</span>;
            }
            <span class="ident">any_massive</span> <span class="op">=</span> <span class="bool-val">true</span>;
        }
    }
    <span class="kw">if</span> <span class="ident">any_massive</span> {
        <span class="prelude-val">Ok</span>((<span class="ident">first_massive</span>, <span class="ident">last_massive</span> <span class="op">+</span> <span class="number">1</span>))
    } <span class="kw">else</span> {
        <span class="prelude-val">Ok</span>((<span class="number">0</span>, <span class="number">0</span>))
    }
}

<span class="doccomment">/// This function calculates the number of nodes that result</span>
<span class="doccomment">/// from the Construction&#39;s discretization.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// For instance, if a construction has only one layer with one</span>
<span class="doccomment">/// element, then that construction has two nodes (one interior and one</span>
<span class="doccomment">/// exterior one). Similarly, if there are two layers but one has no mass,</span>
<span class="doccomment">/// then the first one will add only one node because it will be merged</span>
<span class="doccomment">/// with the exterior film heat transfer coefficient.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Nodes are placed in the joints between elements, and</span>
<span class="doccomment">/// the nodes for the Rsi and Rso layers are considered.</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">calc_n_total_nodes</span>(<span class="ident">n_elements</span>: <span class="kw-2">&amp;</span>[<span class="ident">usize</span>]) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">usize</span>, <span class="ident">String</span><span class="op">&gt;</span> {
    <span class="comment">// We need somethig to process!</span>
    <span class="kw">if</span> <span class="ident">n_elements</span>.<span class="ident">is_empty</span>() {
        <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="string">&quot;Wrong discretization scheme... it contains no elements&quot;</span>.<span class="ident">to_string</span>());
    }

    <span class="comment">// Border case: Only one element.</span>
    <span class="kw">if</span> <span class="ident">n_elements</span>.<span class="ident">len</span>() <span class="op">=</span><span class="op">=</span> <span class="number">1</span> {
        <span class="kw">if</span> <span class="ident">n_elements</span>[<span class="number">0</span>] <span class="op">=</span><span class="op">=</span> <span class="number">0</span> {
            <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="number">2</span>);
        } <span class="kw">else</span> {
            <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">n_elements</span>[<span class="number">0</span>] <span class="op">+</span> <span class="number">1</span>);
        }
    }

    <span class="comment">// Otherwise, let&#39;s do this.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">n</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">1</span>; <span class="comment">// the end node.</span>
    <span class="kw">let</span> (<span class="ident">first_massive</span>, <span class="ident">last_massive</span>) <span class="op">=</span> <span class="ident">get_first_and_last_massive_elements</span>(<span class="ident">n_elements</span>)<span class="question-mark">?</span>;

    <span class="comment">// No massive layer at all in the construction...</span>
    <span class="kw">if</span> <span class="ident">first_massive</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span> <span class="op">&amp;&amp;</span> <span class="ident">last_massive</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span> {
        <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="number">2</span>);
    }

    <span class="comment">// Now, process from the first massive to the last.</span>
    <span class="comment">// interior and exterior no-mass layers do not contribute</span>
    <span class="comment">// nodes.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">in_nomass_layer</span>: <span class="ident">bool</span> <span class="op">=</span> <span class="bool-val">false</span>;
    <span class="kw">for</span> <span class="ident">nodes</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">n_elements</span>[<span class="ident">first_massive</span>..<span class="ident">last_massive</span>] {
        <span class="kw">if</span> <span class="kw-2">*</span><span class="ident">nodes</span> <span class="op">&gt;</span> <span class="number">0</span> {
            <span class="comment">// Material with mass.</span>
            <span class="ident">in_nomass_layer</span> <span class="op">=</span> <span class="bool-val">false</span>;
            <span class="ident">n</span> <span class="op">+</span><span class="op">=</span> <span class="ident">nodes</span>;
        } <span class="kw">else</span> {
            <span class="comment">// material with no-mass</span>
            <span class="kw">if</span> <span class="op">!</span><span class="ident">in_nomass_layer</span> {
                <span class="ident">n</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
                <span class="ident">in_nomass_layer</span> <span class="op">=</span> <span class="bool-val">true</span>;
            }
        }
    }

    <span class="comment">// return</span>
    <span class="prelude-val">Ok</span>(<span class="ident">n</span>)
}

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">calc_r_front</span>(<span class="ident">c</span>: <span class="kw-2">&amp;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Construction</span><span class="op">&gt;</span>, <span class="ident">first_massive</span>: <span class="ident">usize</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Float</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">r_front</span> <span class="op">=</span> <span class="number">0.</span>;
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">first_massive</span> {
        <span class="comment">// let material_index = c.get_layer_index(i).unwrap();</span>
        <span class="kw">let</span> <span class="ident">material</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">c</span>.<span class="ident">materials</span>[<span class="ident">i</span>]; <span class="comment">//model.get_material(material_index).unwrap();</span>
                                        <span class="comment">// let substance_index = material.get_substance_index().unwrap();</span>
        <span class="kw">let</span> <span class="ident">substance</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">material</span>.<span class="ident">substance</span>; <span class="comment">//model.get_substance(substance_index).unwrap();</span>

        <span class="ident">r_front</span> <span class="op">+</span><span class="op">=</span> <span class="ident">material</span>.<span class="ident">thickness</span> <span class="op">/</span> <span class="ident">substance</span>.<span class="ident">thermal_conductivity</span>().<span class="ident">unwrap</span>();
    }
    <span class="ident">r_front</span>
}

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">calc_r_back</span>(<span class="ident">c</span>: <span class="kw-2">&amp;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Construction</span><span class="op">&gt;</span>, <span class="ident">last_massive</span>: <span class="ident">usize</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Float</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">r_back</span> <span class="op">=</span> <span class="number">0.</span>;
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="ident">last_massive</span>..<span class="ident">c</span>.<span class="ident">materials</span>.<span class="ident">len</span>() {
        <span class="kw">let</span> <span class="ident">material</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">c</span>.<span class="ident">materials</span>[<span class="ident">i</span>];
        <span class="kw">let</span> <span class="ident">substance</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">material</span>.<span class="ident">substance</span>;
        <span class="ident">r_back</span> <span class="op">+</span><span class="op">=</span> <span class="ident">material</span>.<span class="ident">thickness</span> <span class="op">/</span> <span class="ident">substance</span>.<span class="ident">thermal_conductivity</span>().<span class="ident">unwrap</span>();
    }
    <span class="ident">r_back</span>
}

<span class="kw">fn</span> <span class="ident">calc_c_matrix</span>(
    <span class="ident">construction</span>: <span class="kw-2">&amp;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Construction</span><span class="op">&gt;</span>,
    <span class="ident">all_nodes</span>: <span class="ident">usize</span>,
    <span class="ident">n_elements</span>: <span class="kw-2">&amp;</span>[<span class="ident">usize</span>],
) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Float</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">c_matrix</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Float</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec!</span>[<span class="number">0.0</span>; <span class="ident">all_nodes</span>];
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">node</span> <span class="op">=</span> <span class="number">0</span>;

    <span class="kw">for</span> <span class="ident">n_layer</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">construction</span>.<span class="ident">materials</span>.<span class="ident">len</span>() {
        <span class="comment">// let layer_index = c.get_layer_index(n_layer).unwrap();</span>
        <span class="kw">let</span> <span class="ident">material</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">construction</span>.<span class="ident">materials</span>[<span class="ident">n_layer</span>]; <span class="comment">//model.get_material(layer_index).unwrap();</span>

        <span class="kw">let</span> <span class="ident">m</span> <span class="op">=</span> <span class="ident">n_elements</span>[<span class="ident">n_layer</span>];

        <span class="kw">if</span> <span class="ident">m</span> <span class="op">!</span><span class="op">=</span> <span class="number">0</span> {
            <span class="comment">// if has mass</span>
            <span class="kw">for</span> <span class="kw">_</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">m</span> {
                <span class="comment">// Calc mass</span>
                <span class="comment">// let substance_index = material.get_substance_index().unwrap();</span>
                <span class="kw">let</span> <span class="ident">substance</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">material</span>.<span class="ident">substance</span>; <span class="comment">//model.get_substance(substance_index).unwrap();</span>

                <span class="kw">let</span> <span class="ident">rho</span> <span class="op">=</span> <span class="ident">substance</span>.<span class="ident">density</span>().<span class="ident">unwrap</span>();
                <span class="kw">let</span> <span class="ident">cp</span> <span class="op">=</span> <span class="ident">substance</span>.<span class="ident">specific_heat_capacity</span>().<span class="ident">unwrap</span>();
                <span class="kw">let</span> <span class="ident">dx</span> <span class="op">=</span> <span class="ident">material</span>.<span class="ident">thickness</span> <span class="op">/</span> (<span class="ident">m</span> <span class="kw">as</span> <span class="ident">Float</span>);
                <span class="kw">let</span> <span class="ident">m</span> <span class="op">=</span> <span class="ident">rho</span> <span class="op">*</span> <span class="ident">cp</span> <span class="op">*</span> <span class="ident">dx</span>; <span class="comment">// dt;</span>

                <span class="comment">// Nodes are in the joints between</span>
                <span class="comment">// finite elements... add half mass from each</span>
                <span class="ident">c_matrix</span>[<span class="ident">node</span>] <span class="op">+</span><span class="op">=</span> <span class="ident">m</span> <span class="op">/</span> <span class="number">2.0</span>;
                <span class="ident">c_matrix</span>[<span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>] <span class="op">+</span><span class="op">=</span> <span class="ident">m</span> <span class="op">/</span> <span class="number">2.0</span>;

                <span class="comment">// advance node.</span>
                <span class="ident">node</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
            }
        } <span class="kw">else</span> {
            <span class="comment">// else, they are zero already...</span>
            <span class="comment">// still, we need to move forward one</span>
            <span class="comment">// node.</span>
            <span class="kw">if</span> <span class="ident">n_layer</span> <span class="op">&gt;</span> <span class="number">0</span> <span class="op">&amp;&amp;</span> <span class="ident">n_elements</span>[<span class="ident">n_layer</span> <span class="op">-</span> <span class="number">1</span>] <span class="op">&gt;</span> <span class="number">0</span> {
                <span class="comment">// Only do it if the previous</span>
                <span class="comment">// layer was massive</span>
                <span class="ident">node</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
            }
        }
    }
    <span class="ident">c_matrix</span>
}

<span class="doccomment">/// Calculates the `K` matrix (i.e., the thermal network) for massive constructions</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Constructions are assumed to be a sandwich where zero or more massive</span>
<span class="doccomment">/// layers are located between two non-mass layers. These non-mass layers will always</span>
<span class="doccomment">/// include the interior and exterior film convections coefficients, respectively (which is</span>
<span class="doccomment">/// why they are called `full_rs_front` and `full_rs_back`, respectively). Additionally,</span>
<span class="doccomment">/// they can also include some lightweight insulation or any other material of negligible</span>
<span class="doccomment">/// thermal mass.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This matrix is constructed based ona discretization of the layers of the</span>
<span class="doccomment">/// construction; that is, each layer is subdivided into `n` elements all of equal</span>
<span class="doccomment">/// thickness. One node is placed at the beginning and end of each elements. Each element can</span>
<span class="doccomment">/// be represented by the 2x2 matrix</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```math</span>
<span class="doccomment">/// \overline{K}=\begin{bmatrix} -1/R &amp; 1/R \\</span>
<span class="doccomment">/// 1/R &amp; -1/R</span>
<span class="doccomment">/// \end{bmatrix}   ;   R=\frac{thickness}{\lambda}</span>
<span class="doccomment">///```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Hence—ignoring external inputs—the K matrix for a construction subdivided into 3 elements (i.e., 4 nodes) can be written as follows:</span>
<span class="doccomment">/// ```math</span>
<span class="doccomment">/// \overline{K}=\begin{bmatrix}</span>
<span class="doccomment">/// -1/R_{1\rightarrow2} &amp; 1/R_{1\rightarrow2} &amp; 0 &amp; 0 \\</span>
<span class="doccomment">/// 1/R_{1\rightarrow2} &amp; -1/R_{1\rightarrow2} - 1/R_{2\rightarrow3} &amp; 1/R_{2\rightarrow3} &amp; 0 \\</span>
<span class="doccomment">/// 0 &amp; 1/R_{2\rightarrow3} &amp; -1/R_{2\rightarrow3} - 1/R_{3\rightarrow4} &amp; 1/R_{3\rightarrow4} \\</span>
<span class="doccomment">/// 0 &amp; 0 &amp; 1/R_{3\rightarrow4} &amp; -1/R_{3\rightarrow4} \\</span>
<span class="doccomment">/// \end{bmatrix}   </span>
<span class="doccomment">///```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Now, these nodes are also connected to an interior and an exterior temperatures through all the</span>
<span class="doccomment">/// layers that do not have any thermal mass both in the interior and exterior (i.e., $`R_{si,full}`$ and $`R_{so,full}`$, respectively).</span>
<span class="doccomment">/// This means that the Matrix $`\overline{K}`$ needs to become:</span>
<span class="doccomment">/// ```math</span>
<span class="doccomment">/// \overline{K}=\begin{bmatrix}</span>
<span class="doccomment">/// -1/R_{1\rightarrow2} - 1/R_{si,full} &amp; 1/R_{1\rightarrow2} &amp; 0 &amp; 0 \\</span>
<span class="doccomment">/// 1/R_{1\rightarrow2} &amp; -1/R_{1\rightarrow2} - 1/R_{2\rightarrow3} &amp; 1/R_{2\rightarrow3} &amp; 0 \\</span>
<span class="doccomment">/// 0 &amp; 1/R_{2\rightarrow3} &amp; -1/R_{2\rightarrow3} - 1/R_{3\rightarrow4} &amp; 1/R_{3\rightarrow4} \\</span>
<span class="doccomment">/// 0 &amp; 0 &amp; 1/R_{3\rightarrow4} &amp; -1/R_{3\rightarrow4}- 1/R_{so,full} \\</span>
<span class="doccomment">/// \end{bmatrix}   </span>
<span class="doccomment">///```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This method returns such a matrix, without the $`R_{si, full}`$ and $`R_{so, full}`$. They need to</span>
<span class="doccomment">/// be added when marching (because these values change over time).</span>
<span class="kw">fn</span> <span class="ident">calc_k_matrix</span>(
    <span class="ident">c</span>: <span class="kw-2">&amp;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Construction</span><span class="op">&gt;</span>,
    <span class="ident">first_massive</span>: <span class="ident">usize</span>,
    <span class="ident">last_massive</span>: <span class="ident">usize</span>,
    <span class="ident">n_elements</span>: <span class="kw-2">&amp;</span>[<span class="ident">usize</span>],
    <span class="ident">all_nodes</span>: <span class="ident">usize</span>,
) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Matrix</span> {
    <span class="comment">// initialize k_prime</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">k_matrix</span> <span class="op">=</span> <span class="ident">Matrix::new</span>(<span class="number">0.0</span>, <span class="ident">all_nodes</span>, <span class="ident">all_nodes</span>);

    <span class="comment">// Calculate what is in between the massive layers</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">node</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">n_layer</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">first_massive</span>;

    <span class="kw">while</span> <span class="ident">n_layer</span> <span class="op">&lt;</span> <span class="ident">last_massive</span> {
        <span class="comment">// let material_index = c.get_layer_index(n_layer).unwrap();</span>
        <span class="kw">let</span> <span class="ident">material</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">c</span>.<span class="ident">materials</span>[<span class="ident">n_layer</span>]; <span class="comment">//model.get_material(material_index).unwrap();</span>

        <span class="kw">let</span> <span class="ident">m</span> <span class="op">=</span> <span class="ident">n_elements</span>[<span class="ident">n_layer</span>];
        <span class="kw">if</span> <span class="ident">m</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span> {
            <span class="comment">// no-mass material</span>
            <span class="comment">// add up all the R of the no-mass layers that</span>
            <span class="comment">// are together</span>
            <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">thermal_resistance</span> <span class="op">=</span> <span class="number">0.0</span>; <span class="comment">// if the material is no mass, then the first value</span>
            <span class="kw">while</span> <span class="ident">n_layer</span> <span class="op">&lt;</span> <span class="ident">last_massive</span> <span class="op">&amp;&amp;</span> <span class="ident">n_elements</span>[<span class="ident">n_layer</span>] <span class="op">=</span><span class="op">=</span> <span class="number">0</span> {
                <span class="comment">// let material_index = c.get_layer_index(n_layer).unwrap();</span>
                <span class="kw">let</span> <span class="ident">material</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">c</span>.<span class="ident">materials</span>[<span class="ident">n_layer</span>]; <span class="comment">//model.get_material(material_index).unwrap();</span>
                <span class="kw">let</span> <span class="ident">dx</span> <span class="op">=</span> <span class="ident">material</span>.<span class="ident">thickness</span>; <span class="comment">//().unwrap();</span>

                <span class="comment">// let substance_index = material.get_substance_index().unwrap();</span>
                <span class="kw">let</span> <span class="ident">substance</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">material</span>.<span class="ident">substance</span>; <span class="comment">//model.get_substance(substance_index).unwrap();</span>
                <span class="kw">let</span> <span class="ident">k</span> <span class="op">=</span> <span class="ident">substance</span>.<span class="ident">thermal_conductivity</span>().<span class="ident">unwrap</span>();

                <span class="ident">thermal_resistance</span> <span class="op">+</span><span class="op">=</span> <span class="ident">dx</span> <span class="op">/</span> <span class="ident">k</span>;
                <span class="ident">n_layer</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
            }

            <span class="comment">// update values</span>
            <span class="kw">let</span> <span class="ident">u_value</span> <span class="op">=</span> <span class="number">1.</span> <span class="op">/</span> <span class="ident">thermal_resistance</span>;
            <span class="comment">// top left</span>
            <span class="kw">let</span> <span class="ident">old_value</span> <span class="op">=</span> <span class="ident">k_matrix</span>.<span class="ident">get</span>(<span class="ident">node</span>, <span class="ident">node</span>).<span class="ident">unwrap</span>();
            <span class="ident">k_matrix</span>.<span class="ident">set</span>(<span class="ident">node</span>, <span class="ident">node</span>, <span class="ident">old_value</span> <span class="op">-</span> <span class="ident">u_value</span>).<span class="ident">unwrap</span>();
            <span class="comment">// top right</span>
            <span class="kw">let</span> <span class="ident">old_value</span> <span class="op">=</span> <span class="ident">k_matrix</span>.<span class="ident">get</span>(<span class="ident">node</span>, <span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>).<span class="ident">unwrap</span>();
            <span class="ident">k_matrix</span>.<span class="ident">set</span>(<span class="ident">node</span>, <span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">old_value</span> <span class="op">+</span> <span class="ident">u_value</span>).<span class="ident">unwrap</span>();
            <span class="comment">// bottom left</span>
            <span class="kw">let</span> <span class="ident">old_value</span> <span class="op">=</span> <span class="ident">k_matrix</span>.<span class="ident">get</span>(<span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">node</span>).<span class="ident">unwrap</span>();
            <span class="ident">k_matrix</span>.<span class="ident">set</span>(<span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">node</span>, <span class="ident">old_value</span> <span class="op">+</span> <span class="ident">u_value</span>).<span class="ident">unwrap</span>();
            <span class="comment">// bottom right</span>
            <span class="kw">let</span> <span class="ident">old_value</span> <span class="op">=</span> <span class="ident">k_matrix</span>.<span class="ident">get</span>(<span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>).<span class="ident">unwrap</span>();
            <span class="ident">k_matrix</span>
                .<span class="ident">set</span>(<span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">old_value</span> <span class="op">-</span> <span class="ident">u_value</span>)
                .<span class="ident">unwrap</span>();

            <span class="comment">// Move one node ahead</span>
            <span class="ident">node</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
        } <span class="kw">else</span> {
            <span class="comment">// calc U value</span>
            <span class="comment">// let substance_index = material.get_substance_index().unwrap();</span>
            <span class="kw">let</span> <span class="ident">substance</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">material</span>.<span class="ident">substance</span>; <span class="comment">//model.get_substance(substance_index).unwrap();</span>

            <span class="kw">let</span> <span class="ident">lambda</span> <span class="op">=</span> <span class="ident">substance</span>.<span class="ident">thermal_conductivity</span>().<span class="ident">unwrap</span>();
            <span class="kw">let</span> <span class="ident">dx</span> <span class="op">=</span> <span class="ident">material</span>.<span class="ident">thickness</span> <span class="op">/</span> (<span class="ident">m</span> <span class="kw">as</span> <span class="ident">Float</span>);
            <span class="kw">let</span> <span class="ident">u</span> <span class="op">=</span> <span class="ident">lambda</span> <span class="op">/</span> <span class="ident">dx</span>;

            <span class="kw">for</span> <span class="kw">_</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">m</span> {
                <span class="comment">// top left</span>
                <span class="kw">let</span> <span class="ident">old_value</span> <span class="op">=</span> <span class="ident">k_matrix</span>.<span class="ident">get</span>(<span class="ident">node</span>, <span class="ident">node</span>).<span class="ident">unwrap</span>();
                <span class="ident">k_matrix</span>.<span class="ident">set</span>(<span class="ident">node</span>, <span class="ident">node</span>, <span class="ident">old_value</span> <span class="op">-</span> <span class="ident">u</span>).<span class="ident">unwrap</span>();
                <span class="comment">// top right</span>
                <span class="kw">let</span> <span class="ident">old_value</span> <span class="op">=</span> <span class="ident">k_matrix</span>.<span class="ident">get</span>(<span class="ident">node</span>, <span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>).<span class="ident">unwrap</span>();
                <span class="ident">k_matrix</span>.<span class="ident">set</span>(<span class="ident">node</span>, <span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">old_value</span> <span class="op">+</span> <span class="ident">u</span>).<span class="ident">unwrap</span>();
                <span class="comment">// bottom left</span>
                <span class="kw">let</span> <span class="ident">old_value</span> <span class="op">=</span> <span class="ident">k_matrix</span>.<span class="ident">get</span>(<span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">node</span>).<span class="ident">unwrap</span>();
                <span class="ident">k_matrix</span>.<span class="ident">set</span>(<span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">node</span>, <span class="ident">old_value</span> <span class="op">+</span> <span class="ident">u</span>).<span class="ident">unwrap</span>();
                <span class="comment">// bottom right</span>
                <span class="kw">let</span> <span class="ident">old_value</span> <span class="op">=</span> <span class="ident">k_matrix</span>.<span class="ident">get</span>(<span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>).<span class="ident">unwrap</span>();
                <span class="ident">k_matrix</span>.<span class="ident">set</span>(<span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">node</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">old_value</span> <span class="op">-</span> <span class="ident">u</span>).<span class="ident">unwrap</span>();

                <span class="comment">// advance node.</span>
                <span class="ident">node</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
            }
            <span class="ident">n_layer</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>;
        }
    }

    <span class="comment">// // ADD RSI AND RSO</span>
    <span class="comment">// // add r_si to first node</span>
    <span class="comment">// if r_front &gt; 0.0 {</span>
    <span class="comment">//     let old_value = k.get(0, 0).unwrap();</span>
    <span class="comment">//     k.set(0, 0, old_value - 1.0 / r_front).unwrap();</span>
    <span class="comment">// }</span>

    <span class="comment">// // rs_o to the last node</span>
    <span class="comment">// if r_back &gt; 0.0 {</span>
    <span class="comment">//     let old_value = k.get(all_nodes - 1, all_nodes - 1).unwrap();</span>
    <span class="comment">//     k.set(all_nodes - 1, all_nodes - 1, old_value - 1.0 / r_back)</span>
    <span class="comment">//         .unwrap();</span>
    <span class="comment">// }</span>
    <span class="comment">// return</span>
    <span class="ident">k_matrix</span>
}

<span class="doccomment">/// Builds the necessary data for marching forward through time, solving the</span>
<span class="doccomment">/// Ordinary Differential Equation that governs the heat transfer in walls.</span>
<span class="doccomment">///</span>
<span class="doccomment">///</span>
<span class="doccomment">/// The equation to solve is the following:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```math</span>
<span class="doccomment">/// \overline{C}  \dot{T} - \overline{K}  T = q</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Where $`\overline{C}`$ and $`\overline{K}`$ are matrices representing the</span>
<span class="doccomment">/// thermal mass of each node and the thermal network, respectively; and where $`T`$ and $`q`$ are</span>
<span class="doccomment">/// vectors representing the Temperature and the heat &quot;flow into&quot; each node, respectively.</span>
<span class="doccomment">/// $`\overline{C}`$ and $`\overline{K}`$ are build based on the finite difference method.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This model uses a 4th order [Runga-Kutte](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods) (a.k.a., RK4)</span>
<span class="doccomment">/// to march through time. In order to do this, it is convenient to write the equation to solve</span>
<span class="doccomment">/// as follows:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// ```math</span>
<span class="doccomment">/// \dot{T}  = f(t, T)</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Where</span>
<span class="doccomment">/// ```math</span>
<span class="doccomment">/// f(t,T) = \overline{C}^{-1} \overline{K}  T + \overline{C}^{-1} q</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Note that—unless some layer of the Surface is generating heat—all the elements of $`q`$ are Zero</span>
<span class="doccomment">/// exept the first one and the last one, which are $`\frac{T_{in}}{R_{si}}`$ and $`\frac{T_{out}}{R_{so}}`$,</span>
<span class="doccomment">/// respectively.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Then, the 4th order Runge-Kutta method allows marching forward through time as follows:</span>
<span class="doccomment">/// ```math</span>
<span class="doccomment">///  T_{i+1} = T_i + \frac{k_1 + 2k_2 + 2k_3 + k_4}{6}</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">/// Where $`k_1`$, $`k_2`$, $`k_3`$ and $`k_4`$ can be calculated based on the</span>
<span class="doccomment">/// timestep $`\Delta t`$ as follows:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// * $`k_1 = \Delta t \times f(t,T)`$</span>
<span class="doccomment">/// * $`k_2 = \Delta t \times f(t+\frac{\Delta t}{2}, T+\frac{k_1}{2})`$</span>
<span class="doccomment">/// * $`k_3 = \Delta t \times f(t+\frac{\Delta t}{2}, T+\frac{k_2}{2})`$</span>
<span class="doccomment">/// * $`k_4 = \Delta t \times f(t+\delta t, T+k_3 )`$</span>
<span class="doccomment">///</span>
<span class="doccomment">/// So, what this method does is to calculate what is needed in order to return a closure that</span>
<span class="doccomment">/// calculates $`\Delta t \times f(t,T)`$; that is to say:</span>
<span class="doccomment">/// ```math</span>
<span class="doccomment">/// return = \Delta t \times f(t,T) = \Delta t \times \overline{C}^{-1} \overline{K}  T + \Delta t \times \overline{C}^{-1} q</span>
<span class="doccomment">/// ```</span>
<span class="doccomment">/// It is worth mentioning that, due to efficiency reasons, the following variables are defined</span>
<span class="doccomment">/// within the code:</span>
<span class="doccomment">/// * $`\overline{K}^{\star} = \Delta t \times \overline{C}^{-1}\overline{K}`$</span>
<span class="doccomment">/// * $`\overline{C}^{\star} = \Delta t \times \overline{C}^{-1}`$</span>
<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">build_thermal_network</span>(
    <span class="ident">construction</span>: <span class="kw-2">&amp;</span><span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">Construction</span><span class="op">&gt;</span>,
    <span class="ident">first_massive</span>: <span class="ident">usize</span>,
    <span class="ident">last_massive</span>: <span class="ident">usize</span>,
    <span class="ident">dt</span>: <span class="ident">Float</span>,
    <span class="ident">all_nodes</span>: <span class="ident">usize</span>,
    <span class="ident">n_elements</span>: <span class="kw-2">&amp;</span>[<span class="ident">usize</span>],
    <span class="ident">r_front</span>: <span class="ident">Float</span>,
    <span class="ident">r_back</span>: <span class="ident">Float</span>,
) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="kw">impl</span> <span class="ident">Fn</span>(<span class="kw-2">&amp;</span><span class="ident">Matrix</span>, <span class="ident">Float</span>, <span class="ident">Float</span>, <span class="ident">Float</span>, <span class="ident">Float</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Matrix</span>, <span class="ident">String</span><span class="op">&gt;</span> {
    <span class="comment">// if this happens, we are trying to build the</span>
    <span class="comment">// thermal network for a non-massive wall... Which</span>
    <span class="comment">// does not make sense</span>
    <span class="macro">debug_assert!</span>(<span class="ident">first_massive</span> <span class="op">!</span><span class="op">=</span> <span class="ident">last_massive</span>);
    <span class="macro">debug_assert_eq!</span>(<span class="ident">calc_n_total_nodes</span>(<span class="ident">n_elements</span>).<span class="ident">unwrap</span>(), <span class="ident">all_nodes</span>);

    <span class="comment">// check coherence in input data</span>
    <span class="kw">if</span> <span class="ident">n_elements</span>.<span class="ident">len</span>() <span class="op">!</span><span class="op">=</span> <span class="ident">construction</span>.<span class="ident">materials</span>.<span class="ident">len</span>() {
        <span class="kw">let</span> <span class="ident">err</span> <span class="op">=</span> <span class="macro">format!</span>(<span class="string">&quot;Mismatch between number of layers in construction ({}) and the number of elements in scheme ({})&quot;</span>,<span class="ident">construction</span>.<span class="ident">materials</span>.<span class="ident">len</span>(),<span class="ident">n_elements</span>.<span class="ident">len</span>());
        <span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">err</span>);
    }

    <span class="comment">// initialize k_prime as K... we will modify it later</span>
    <span class="comment">// K_prime = dt*inv(C)*K</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">k_prime</span> <span class="op">=</span> <span class="ident">calc_k_matrix</span>(
        <span class="ident">construction</span>,
        <span class="ident">first_massive</span>,
        <span class="ident">last_massive</span>,
        <span class="ident">n_elements</span>,
        <span class="comment">// rs_front,</span>
        <span class="comment">// rs_back,</span>
        <span class="ident">all_nodes</span>,
    );

    <span class="comment">// Calc the masses</span>
    <span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">calc_c_matrix</span>(<span class="ident">construction</span>, <span class="ident">all_nodes</span>, <span class="ident">n_elements</span>);

    <span class="comment">// DIVIDE ONE BY THE OTHER to make K_prime</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">c_prime</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Float</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Vec::with_capacity</span>(<span class="ident">all_nodes</span>);
    <span class="kw">for</span> (<span class="ident">i</span>, <span class="ident">mass</span>) <span class="kw">in</span> <span class="ident">c</span>.<span class="ident">iter</span>().<span class="ident">enumerate</span>() {
        <span class="kw">if</span> <span class="kw-2">*</span><span class="ident">mass</span> <span class="op">!</span><span class="op">=</span> <span class="number">0.0</span> {
            <span class="comment">// Multiply the whole column K by this.</span>
            <span class="kw">for</span> <span class="ident">j</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">all_nodes</span> {
                <span class="kw">let</span> <span class="ident">old_k_value</span> <span class="op">=</span> <span class="ident">k_prime</span>.<span class="ident">get</span>(<span class="ident">i</span>, <span class="ident">j</span>).<span class="ident">unwrap</span>();
                <span class="ident">k_prime</span>.<span class="ident">set</span>(<span class="ident">i</span>, <span class="ident">j</span>, <span class="ident">dt</span> <span class="op">*</span> <span class="ident">old_k_value</span> <span class="op">/</span> <span class="ident">mass</span>).<span class="ident">unwrap</span>();
            }
            <span class="ident">c_prime</span>.<span class="ident">push</span>(<span class="ident">dt</span> <span class="op">/</span> <span class="ident">mass</span>);
        } <span class="kw">else</span> {
            <span class="macro">unreachable!</span>()
        }
    }

    <span class="comment">// SET C_I AND C_O</span>
    <span class="comment">// *c_i = c[0]/dt;</span>
    <span class="comment">// *c_o = c[all_nodes - 1]/dt;</span>

    <span class="comment">// *given_k_prime = k_prime;</span>

    <span class="comment">// let r_front = calc_r_front(construction, first_massive);</span>
    <span class="comment">// let r_back = calc_r_back(construction, last_massive);</span>

    <span class="kw">let</span> <span class="ident">clo</span> <span class="op">=</span> <span class="kw">move</span> <span class="op">|</span><span class="ident">nodes_temps</span>: <span class="kw-2">&amp;</span><span class="ident">Matrix</span>,
                    <span class="ident">t_front</span>: <span class="ident">Float</span>,
                    <span class="ident">t_back</span>: <span class="ident">Float</span>,
                    <span class="ident">rs_front</span>: <span class="ident">Float</span>,
                    <span class="ident">rs_back</span>: <span class="ident">Float</span><span class="op">|</span>
          <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Matrix</span> {
        <span class="kw">let</span> <span class="ident">full_rs_front</span> <span class="op">=</span> <span class="ident">r_front</span> <span class="op">+</span> <span class="ident">rs_front</span>;
        <span class="kw">let</span> <span class="ident">full_rs_back</span> <span class="op">=</span> <span class="ident">r_back</span> <span class="op">+</span> <span class="ident">rs_back</span>;
        <span class="kw">let</span> <span class="ident">ts_front</span> <span class="op">=</span> <span class="ident">nodes_temps</span>.<span class="ident">get</span>(<span class="number">0</span>, <span class="number">0</span>).<span class="ident">unwrap</span>();
        <span class="kw">let</span> <span class="ident">ts_back</span> <span class="op">=</span> <span class="ident">nodes_temps</span>.<span class="ident">get</span>(<span class="ident">all_nodes</span> <span class="op">-</span> <span class="number">1</span>, <span class="number">0</span>).<span class="ident">unwrap</span>();

        <span class="comment">// Calculate: k_i = dt*inv(C) * q + h*inv(C)*k*T</span>
        <span class="comment">// But, dt*inv(C) = c_prime | h*inv(C)*k = k_prime</span>
        <span class="comment">// --&gt; Calculate: k_i = c_prime * q + k_prime * T</span>

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">k_i</span> <span class="op">=</span> <span class="ident">k_prime</span>.<span class="ident">from_prod_n_diag</span>(<span class="ident">nodes_temps</span>, <span class="number">3</span>).<span class="ident">unwrap</span>();

        <span class="comment">// if we are generating heat in any layer (e.g., radiant floor) this</span>
        <span class="comment">// would need to change...</span>
        <span class="kw">let</span> <span class="ident">old_value</span> <span class="op">=</span> <span class="ident">k_i</span>.<span class="ident">get</span>(<span class="number">0</span>, <span class="number">0</span>).<span class="ident">unwrap</span>();
        <span class="ident">k_i</span>.<span class="ident">set</span>(
            <span class="number">0</span>,
            <span class="number">0</span>,
            <span class="ident">old_value</span>
            <span class="comment">/* Add RSFront */</span> <span class="op">-</span> <span class="ident">c_prime</span>[<span class="number">0</span>] <span class="op">*</span> <span class="ident">ts_front</span> <span class="op">/</span> <span class="ident">full_rs_front</span>
            <span class="comment">/* And the heat flow*/</span> <span class="op">+</span> <span class="ident">c_prime</span>[<span class="number">0</span>] <span class="op">*</span> <span class="ident">t_front</span> <span class="op">/</span> <span class="ident">full_rs_front</span>,
        )
        .<span class="ident">unwrap</span>();

        <span class="kw">let</span> <span class="ident">old_value</span> <span class="op">=</span> <span class="ident">k_i</span>.<span class="ident">get</span>(<span class="ident">all_nodes</span> <span class="op">-</span> <span class="number">1</span>, <span class="number">0</span>).<span class="ident">unwrap</span>();
        <span class="ident">k_i</span>.<span class="ident">set</span>(
            <span class="ident">all_nodes</span> <span class="op">-</span> <span class="number">1</span>,
            <span class="number">0</span>,
            <span class="ident">old_value</span>
            <span class="comment">/* Add RSBack */</span> <span class="op">-</span> <span class="ident">c_prime</span>[<span class="ident">all_nodes</span> <span class="op">-</span> <span class="number">1</span>] <span class="op">*</span> <span class="ident">ts_back</span> <span class="op">/</span> <span class="ident">full_rs_back</span>
            <span class="comment">/* And the heat flow*/</span> <span class="op">+</span> <span class="ident">c_prime</span>[<span class="ident">all_nodes</span> <span class="op">-</span> <span class="number">1</span>] <span class="op">*</span> <span class="ident">t_back</span> <span class="op">/</span> <span class="ident">full_rs_back</span>,
        )
        .<span class="ident">unwrap</span>();

        <span class="comment">// return</span>
        <span class="ident">k_i</span>
    };

    <span class="prelude-val">Ok</span>(<span class="ident">clo</span>)
    <span class="comment">// Ok(())</span>
}
</code></pre></div>
</section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="thermal" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script>
</body></html>